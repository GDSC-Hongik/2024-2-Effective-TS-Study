### 아이템19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

타입스크립트는 우리가 생각하기 보다 타입 추론에서 더 정확하게 추론함.

→ 문자열 리터럴의 경우 string으로 선언해버리면 추론한 결과인 리터럴 값보다 덜 정확해짐.

- 정보가 부족할 경우 타입스크립트가 추론하지 못함 ⇒ 타입스크립트는 최종 사용처까지 고려하지 않음.
  - 타입스크립트의 변수의 타입은 처음 등장할 때 결정됨.
  - 타입 구문을 생략하여 방해되는 것들을 최소화하고, 코드를 읽는 사람이 로직에 집중하도록 함 → 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내 지역변수에는 타입 구문을 넣지 않음.
  _⇒ 타입스크립트가 왜 생겼는지를 생각해보면 당연한 것. 파이썬을 쓰다보면 가끔 타입 선언의 필요성을 느낄 때가 있긴 함(타입이 헷갈려서). 하지만 대부분의 경우 타입 선언이 없는게 이해하기 편함._

```tsx
// 이렇게 하지 맙시다.
app.get("/health", (request: express.Request, response: express.Response) => {
  response.send("OK");
});

// 이렇게 합시다.
app.get("/health", (request, response) => {
  response.send("OK");
});
```

express HTTP 라이브러리처럼 타입 정보가 있는 라이브러리에서 콜백 함수의 매개변수 타입은 자동으로 추론.

- 타입 추론이 됨에도 타입 선언하는 상황
  - 객체 리터럴을 정의할 경우 → 정의에 타입을 선언하면 **잉여 속성 체크**가 동작함.
    - 잉여 속성 체크는 선택적 속성이 있는 타입의 오타 같은 오류를 잡는데 효과적임.
    - 변수가 사용되는 순간이 아닌, 할당되는 순간에 오류를 표시해줌.
    - 만약, 타입 구문을 제거하면 잉여 속성 체크가 동작하지 않음.
  - 함수의 반환 타입을 명시함.
    - 구현상의 오류가 함수를 호출한 곳까지 영향을 미치지 않도록. (의도된 반환 타입대로)
    - Promise와 관련된 특정 오류를 피하기 위해서는 async 함수가 효과적임. [아이템25. 비동기 코드에는 콜백 대신 async 함수 사용하기](https://www.notion.so/25-async-14287aa7ba5e803da3f3dbf77d732ad2?pvs=21)
    1. 반환 타입을 명시하면 함수에 대해 명확하게 알 수 있음.
       - 구현 전에 입력/출력 타입을 알아야 함. → 코드가 변경돼도 함수의 시그니처는 변하지 않음. (미리 적는 것은 `TDD`와 비슷함.)
       - 전체 타입 시그니처를 먼저 작성해야 구현에 치중한 개발이 되지 않음.
    2. 명명된 타입을 사용하기 위함.

       ```tsx
       interface Vector2D {
         x: number;
         y: number;
       }
       function add(a: Vector2D, b: Vector2D) {
         return { x: a.x + b.x, y: a.y + b.y };
       }
       ```

eslint: `no-inferrable-types` → 작성된 모든 타입 구문이 정말로 필요한 것인가?

_처음에는 타입스크립트를 이용한다면, 모든 타입을 확실하게 기재하여 “확실하고 치밀한” 코드를 짜야한다고 생각했으나, 어쨌든 사람이 짜는 코드라는 점, 그리고 타입 추론이 있다는 점에서 무조건적인 타입 선언이 오히려 마이너스가 된다고 느껴졌다._

_결국 고급 언어가 생겨난 이유도 인간이 이해하기 좋은 코드를 짜기 위함이 아닌가라는 생각…_
