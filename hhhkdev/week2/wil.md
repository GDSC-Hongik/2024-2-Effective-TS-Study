# 2주차 스터디

## 2장: 타입스크립트의 타입 시스템

### 아이템9. 타입 단언보다는 타입 선언을 사용하기

`as`를 이용하여 타입을 정의해주는 것이 **타입 단언 → 타입스크립트가 추론한 타입이 있더라도 해당 타입으로 간주함.**

타입 선언: 할당되는 값이 해당 인터페이스를 만족시키는지 점검함 → 타입 단언은 오류를 무시해버림.

(객체 리터럴은 알려진 속성만 지정할 수 있음. → **잉여 속성 체크**) → 단언문에서는 잉여 속성 체크가 안됨.

> 결국 안전성 체크가 되는 타입 선언을 우선적으로 사용해야 함.

<aside>
- 화살표 함수에서의 타입 선언 (p.54 예제)

화살표 함수에서의 타입은 반환값을 화살표 함수의 리턴문쪽에서 선언하여 원하는 결과가 나오도록 함.

→ 반환 타입을 명시하여 간단하게 표현 가능

</aside>

> 함수 호출 체이닝이 연속되는 곳에서는 체이닝 시작부터 명명된 타입을 가져야함.
> → 정확한 곳에 오류가 표시되도록.

<aside>
- **타입 단언**이 꼭 필요한 경우: 타입 체커보다 우리가 판단하는 타입이 더 정확할 경우.

→ 타입 단언이 필요하다면 앞에서 타입 선언을 제대로 못했기 때문이 아닐까?

→ DOM 엘리먼트의 경우 타입스크립트에서 DOM에 접근을 못하므로 알 수 없음.

</aside>

`!`가 접미사로 사용될 경우: 해당 값이 `null`이 아님을 보장하는 단언문.

**서브타입(부분집합)**일 경우에는 타입 단언문을 사용해 변환할 수 있음. → unknown을 활용해 단언한다면 항상 동작함. **모든 타입은 unknown의 서브타입.**

### 아이템10. 객체 래퍼 타입 피하기

`string`은 기본형임에도 메서드를 갖고 있는 것으로 보임. → 스트링 기본형은 메서드가 없지만, 자바스크립트에는 메서드를 가지는 **`String 객체 타입`**이 정의됨.

→ 메서드를 사용하면 기본형을 String 객체로 래핑하고, 메서드를 호출하고, 래핑한 객체를 버림.

`String.prototype`을 몽키패치 한다면 관찰 가능. → 런타임에 프로그램의 어떤 기능을 수정해서 사용하는 기법. 주로 프로토타입을 변경하는 것.

- 버린다는 특성 때문에, 속성을 추가할 수 있지만 속성이 추가된 객체가 버려지며 속성이 사라짐.

사실 웬만한 경우에는 string이나 String을 혼용해서 사용해도 문제가 없지만, string을 매개변수로 받는 메서드에서 문제가 발생함.

> **string은 String에 할당할 수 있지만, String은 string에 할당할 수 없음.**

→ 타입 선언에도 대문자를 이용한 객체 래퍼를 사용할 수 있지만, 기본형을 쓰는게 맞음.

- [ ] 객체 래퍼를 타입 선언에 활용하는 경우도 있는가?

### 아이템11. 잉여 속성 체크의 한계 인지하기

`아이템18`, `아이템26`

(객체 리터럴) 타입스크립트는 **해당 타입의 속성이 있는지, 그 외의 속성은 없는지 검사함**.

→ 구조적 타이핑의 관점에서는 다른 속성이 있더라도 오류가 발생하지 않아야 함.

다만 리터럴이 아니라 객체에 변수를 도입하여 타입에 할당하는 것은 가능하며 타입 체커도 통과함.

<aside>
**[잉여 속성 체크**]

→ 할당 가능 검사와 별도의 과정. 객체 리터럴에 알 수 없는 속성을 허용하지 않음.

→ 객체 리터럴이 아닌 실제 객체인 경우 잉여 속성 체크가 되지 않음. 단언문일 때도 적용 안됨.

- 속성 이름의 오타같은 실수를 잡는데 효과적.
</aside>

- 잉여 속성 체크가 싫으면 인덱스 시그니처를 통해 타입스크립트가 추가적인 속성을 예측할 수 있도록 함.

**[공통 속성 체크]** 값 타입과 선언 타입에 공통된 속성이 있는가. (선택적 속성으로 인해 약한 타입인 경우.)

### 아이템12. 함수 표현식에 타입 적용하기

함수 문장과 함수 표현식은 다른 개념. → 타입스크립트는 **함수 표현식**을 사용하는 것이 좋음.
(함수의 매개변수부터 반환값까지 전체를 함수 타입으로 인식하여 재사용 가능함.)

- 불필요한 코드 반복을 줄이며, 함수 시그니처를 하나의 함수 타입으로 통합 가능함.
- 다른 함수의 시그니처를 참조하려면 `typeof`를 이용함.

### 아이템13. 타입과 인터페이스의 차이점 알기

명명된 타입을 정의하는 방법: 타입, 인터페이스 (인터페이스의 접두사에 I를 붙이는 것은 C#의 관례.)

인터페이스는 **유니온 타입과 같은 복잡한 타입**을 확장하지 못함. → 유니온 인터페이스는 없음.

⇒ 일반적으로 `type` 키워드는 인터페이스보다 쓰임새가 많음.

- 튜플과 배열 타입도 더 간결하게 표현 가능함. (인터페이스도 튜플의 구현은 가능하지만, 메서드를 사용할 수 없음.)

<aside>
**인터페이스의 기능**

**보강**이 가능하다는 것 → 필드를 추가할 때 다시 선언할 수 있음. **[선언 병합]**

</aside>

선언 병합의 예제) Array 인터페이스 → ES2015를 추가할 경우 기존에 선언된 인터페이스에 병합됨.

⇒ 프로퍼티가 추가되는 것을 원치 않으면 타입을 사용해야 함.

> 일관성과 보강의 관점에서 고려해야 함. (보강이 필요한가)

### 아이템14. 타입 연산과 제너릭 사용으로 반복 줄이기

> `DRY` (Don’t Repeat Yourself): 같은 코드를 반복하지 말라.

단순 코드의 반복이 아닌 타입의 반복 또한 문제.

- 타입에서의 중복 ← 공유된 패턴을 제거하는 매커니즘이 덜 익숙함.

<aside>
1. 타입의 이름을 붙이는 것.
2. 함수의 동일한 내용을 시그니처로 분리시킬 수 있음.
</aside>

이미 존재하는 타입을 확장할 경우에는 **인터섹션 연산자**(`&`)를 이용할 수 있음.

속성의 일부만 표현하는 타입의 경우 → 기존 속성을 인덱싱하여 접근할 수 있음. → **매핑된 타입으로 더 짧게 표현 가능함.**

- State와 TopNavState의 예시 (p.78 예시)
- 표준 라이브러리 `Pick<T, K>`
- 태그된 유니온에서 유니온을 인덱싱하여 타입을 정의할 수 있음. (p.79 예시)
- 매핑된 타입과 keyof를 사용하여 선택적 속성인 타입을 만들 수 있음. (p.80 예시)

<**`제너릭 타입`**> 타입을 위한 함수

- **제너릭 타입에서 매개변수를 제한할 수 있는 방법**: `extends`를 이용하여 특정 타입을 확장한다고 선언함. (`extends`를 확장이 아니라 부분집합이라는 관점에서 접근해야 함.)

→ Pick에서 K의 타입을 제한하기 위해 T의 타입으로 제한하는 식으로 작성할 수 있음.

---

### keyof 연산자

특정 객체 타입으로부터 프로퍼티 키들을 모두 스트링 리터럴 유니온 타입으로 추출하는 연산자

> 프로퍼티로 객체의 키를 문자열로 넣고 싶을 때, 문자열 리터럴 유니온을 이용할 수 있음 → keyof 연산자를 이용하여 추출해낼 수 있음.

- typeof 연산자: 타입을 정의할 때도 타입을 뽑아내는 용도로 사용할 수 있음.

```tsx
keyof <Type> // 해당 타입의 프로퍼티의 스트링 리터럴 유니온
keyof typeof <Instance> // 해당 객체의 프로퍼티의 스트링 리터럴 유니온
```

### 맵드 타입

기존의 객체 타입으로부터 새로운 객체 타입을 만드는 타입

```tsx
interface User {
  id: number;
  name: number;
  age: number;
}

type PartialUser = {
  [key in "id" | "name" | "age"]?: User[key];
};

type BooleanUser = {
  [key in keyof User]: number;
};
```

- 맵드 타입은 인터페이스에서 사용 못함. 타입 별칭에서만 사용할 수 있으며 실무 사용도가 높음.

---

### 아이템15. 동적 데이터에 인덱스 시그니처 사용하기

자바스크립트의 장점: 객체를 생성하는 문법이 간단하다는 것. **`인덱스 시그니처`**를 명시해 매핑을 표현함.

- 인덱스 시그니처의 의미: 키의 이름, 키의 타입(보통 string), 값의 타입
- 단점: 모든 키를 허용함.(잘못된 키도), 특정 키가 필요하지 않음. 키마다 같은 키 타입을 가져야 함. 등…

⇒ 인덱스 시그니처는 부정확하기 때문에 더 나은 방법을 찾아야 함. → 인덱스 시그니처는 동적 데이터에 유리함.

<aside>
**키가 있지만 얼마나 있는지 모를 경우**

- 인덱스 시그니처를 활용함 → 너무 광범위함.
- `?`를 활용하여 선택적 필드를 이용하거나, 유니온 타입으로 모델링함.
</aside>

- Record 제너릭 타입을 이용함. (p.88 예시)

### 아이템16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

복잡한 객체를 키로 사용하려고 하면 toString 메서드가 호출되어 문자열로 키가 사용됨.

배열은 객체이기 때문에 문자열 키를 사용해도 접근 가능함.

<aside>
- 인덱스를 신경쓰지 않는 다면 → `for-of`
- 인덱스의 타입이 중요하다면 → `Array.prototype.forEach`
- 타입이 불확실하다면 → `for-in`은 몇 배나 느림.
</aside>

ArrayLike: 배열과 비슷한 형태의 튜플을 이용할 때 사용함.

⇒ 어차피 배열에서는 다 키가 문자열로 바뀌니 다른 형식을 사용해야 함.

### 아이템17. 변경 관련된 오류 방지를 위해 readonly 사용하기

<aside>
**Readonly의 특징**

- 배열의 요소를 읽을 순 있지만, 쓸 수는 없음.
- length를 읽을 수 있지만, 바꿀 수는 없음. (배열을 변경함)
- 배열을 변경하는 메서드를 호출할 수 없음.
</aside>

기능이 더 많다는 것은 서브타입이라는 뜻.

readonly를 사용하면 `지역변수`와 관련된 모든 종류의 변경 오류르 방지할 수 있음.

- readonly의 인수는 일반 매개변수에 할당할 수 없음.
- 읽기 전용 속성이기 때문에 length를 할당하거나 push 등의 속성이 없음.

⇒ 변경 가능성을 `let`과 `concat`을 이용하여 확장시킴.

> `readonly`를 최대한 써야하지만 썼을 때 제한되는 유동성을 어떻게 확보할 것인가에 대한 아이템

- [ ] const와 readonly의 차이점

### 아이템18. 매핑된 타입을 사용하여 값을 동기화하기

매핑 → 한 객체와 또 다른 객체가 정확히 같은 속성을 갖게 할 때 이상적임.
