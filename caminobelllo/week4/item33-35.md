## [아이템 33] string 타입보다 더 구체적인 타입 사용하기

타입에는 최대한 구체적인, 즉 좁은 타입을 사용하는 것이 좋다.

다음과 같은 예를 보면,

```
/** (1) 녹음 환경 */
type RecordingType = "sudio" | "live";

type Album = {
  artist: string;
  title: string;
  releaseData: Date;
  recordingType: RecordingType;
};
```

더욱 구체적인 타입을 타입체커에 전달함으로써

1. RecordingType을 분리해 다른 곳에서 활용
2. 분리된 타입에 주석으로 설명
3. keyof를 이용한 세밀한 속성체크
   위 3가지가 가능해진다.

따라서 string 보다는 문자열 리터럴에 유니온으로 타입을 생성하는 등의 더 구체적인 타입을 지정하는 것이 좋다.
또한 객체의 속성 이름을 매개변수로 받는 경우 `keyof T` 나 템플릿으로 `K extends keyof T` 와 같은 형식을 사용하자. 그러면 더 구체적인 타입으로 추론이 된다.

## [아이템 34] 부정확한 타입보다는 미완성 타입 만들기

타입스크립트를 쓸 때는 타입 선언의 정밀도를 높이는 것에 주의를 기울여야 한다.

다음과 같은 예시에서

```
// (1)
type Coord1 = number[];

// (2)
type Coord2 = [number, number];
```

좌표를 의미할 때는 1번 예시보다 2번 예시처럼 사용해 더욱 명확하게 표현하는 것이 좋다. 하지만 의도에 따라 첫번째가 맞을 수 있다. 예를 들어 3개 이상의 좌표를 갖는 타입인 경우.

```
type FnName = "+" | "-" | "*" | "/" | ">" | "<" | "case" | "rgb";
type CallExpression = [FnName, ...any[]];
type Expression3 = number | string | CallExpression;

const tests2: Expression3[] = [
  10,
  "red",
  true, // Error: 'boolean' 형식은 'Expression3' 형식에 할당할 수 없습니다.
  ["+", 10, 5],
  ["case", [">", 20, 10], "red", "blue", "green"], // (5) 정상 동작
  ["**", 2, 31], // Error: '"**"' 형식은 'FnName' 형식에 할당할 수 없습니다.
  ["rgb", 255, 255, 255],
  ["rgb", 255, 255, 255, 0.5], // (5) 정상 동작
];
```

이처럼 타입을 구체적으로 지정해서 타입 체커가 에러를 발생 시키는 경우, 만약 불필요한 값이 더 들어가있다는 에러가 아닌 다른 곳에서 문제가 발생했다고 에러 메세지를 뱉기 때문에 개발자는 문제의 원인을 파악하기 어려워 진다.

더 구체적일수록 에러를 잘 잡아낼 수 있지만 에러가 발생했을 때 의도에 맞지 않은 다른 메세지를 표시하기 때문에 개발 경험을 해칠 수 있다는 것이다.

이를 통해, 너무 정확하게 만드려다 오히려 부정확한 타입을 만들 수 있기 때문에 정확한 타입 모델링이 어려운 경우라면 차라리 미완성의 타입으로 남겨두는 것이 더 좋을 때가 있다라는 의도를 전달하고자 하는 아이템인 것 같다.

## [아이템 35] 데이터가 아닌 API와 명세를 보고 타입 만들기

데이터만 보고 타입을 만들기보단 명세를 보고 타입을 만드는 것이 명확하다.

왜냐하면 주고 받는 데이터만으로 타입을 만들면 모든 예외적인 경우를 파악할 수 없기 때문에 정확하지 않은 타입을 만들 가능성이 높아지고, 해당 타입이 optional인지, 특정 상황에만 존재하는지와 같은 상세한 내용은 알 수 없기 때문이다.

또한 타입을 만들어서 제공해주는 라이브러리를 사용한다면 제공하는 타입을 활용하는 것이 가장 좋다. (이 경우는 타입이 변경된다면 그에 맞춰 자동으로 업데이트 된다.)

- [ ] prisma가 제공해 주는 타입 사용
