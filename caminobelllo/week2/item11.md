## [아이템 11] 잉여 속성 체크의 한계 인지하기

### 잉여 속성 체크

타입에 선언된 속성 외에 다른 속성이 있는지 체크하는 것이다.

(예시 1)

```
interface Room {
    numDoors: number;
    ceilingHeightFt: number;
}

const r: Room = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
}
```

위 예제는 r 변수에 Room 타입을 할당함과 동시에 객체 리터럴을 생성하는 코드이다.

이처럼 **변수에 타입을 선언함과 동시에 객체 리터럴로 만들게 되면 잉여 속성이 체크된다.**

따라서 이 경우에는 elephant 속성은 Room 타입에 존재하지 않는다는 에러가 발생한다.

<br/>

하지만 앞서 공부한 구조적 타이핑 관점에서 생각하면 이 코드는 오류가 발생하면 안되는 것이 아닌가 하는 생각이 든다.

임시 변수를 도입한 코드를 보며 생각해보자.

결론적으로는 아래와 같은 경우에는 _잉여 속성이 체크되지 않는데,_

(예시 2)

```
const obj = {
        numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present',
};

const r: Room = obj;    // 정상
```

정상적으로 `r`이라는 변수에 `obj` 변수가 할당되었고, 이 과정에서 잉여 속성 체크는 진행되지 않았다.

<br />

이때 우리는,

#### 할당 가능 검사와 깅여 속성 체크는 별도의 과정이라는 것을 알아야 한다.

앞의 예시 1과 2는 모두 할당 가능 검사를 통과했다. 그러나 잉여 속성 체크는 1번 예시에서만 동작한다.

<br />

잉여 속성 체크는 객체 리터럴에 알 수 없는 속성을 허용하지 않기 떄문에, 에러를 방지하기 좋다. **('엄격한 객체 리터럴 체크')**

잉여 속성 체크를 하지 않는 방법으로는

1. 타입 구문 없는 임시 변수 사용 (객체 리터럴이 아님)
2. 타입 단언 사용하기
3. 인덱스 시그니처 사용
