## [아이템 15] 동적 데이터에 인덱스 시그니처 사용하기

인덱스 시그니처는 다음과 같은 구조다.

```
type IndexSignatureType = { [property: string]: string };
// [property: string]: string
// (키의 이름)  (키의 타입) (값의 타입)
```

이때 property는 키의 위치를 표현하는 용도로 사용된다.

지난 아이템에서, 객체 순회 시 에러를 우회하는 방법으로 인덱스 시그니처를 사용할 수 있다고 하였다.

다음같은 단점들 때문에 해당 아이템에서는 **동적 데이터가 아니라면 되도록 인덱스 시그니처의 사용을 피하자**라는 것이 주제이다.

1. 모든 키를 허용하기 때문에 객체에 없는 키를 사용하더라도 타입 체크 시에 에러가 발생하지 않는다.
2. 특정 키가 필요하지 않기 때문에 {} 과 같은 empty object도 할당이 가능하다.
3. 키마다 다른 타입을 가질 수 없다. 그렇기 때문에 값의 타입을 union 타입으로 확장시켜야 한다.
4. 타입스크립트의 언어 서비스를 제공받을 수 없다.

이런 점들 때문에 인덱스 시그니처가 아닌 다른 방법을 사용해야 한다.

타입의 키들이 무엇이 될 지 아는 경우에는 인덱스 시그니처를 사용하는 것보다 타입을 직접 선언해 주는 것이, 타입의 안전성 측면에서 더 좋다. 하지만 타입을 직접 선언하는 것은 번거롭기 때문에 다음과 같은 방법들을 활용하자.

### 1. 유틸리티 타입 레코드 사용하기

```
type Record<K extends keyof any, T> = {
    [P in K]: T;
};
```

### 2. 매핑된 타입 사용하기

- 인터페이스에서는 매핑된 타입을 사용할 수 없음에 유의해야 한다.
