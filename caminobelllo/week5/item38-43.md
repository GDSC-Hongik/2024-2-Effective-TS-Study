# 5장. any 다루기

## [아이템 38] any 타입은 가능한 한 좁은 범위에서만 사용하기

**함수**와 관련한 any 사용에서는 any 타입이 다른 코드나 함수 바깥으로 영향을 미치지 않도록 하는 것이 중요하다. 그런 의미에서 `x: any`는 다른 코드에도 영향을 미칠 수 있기 때문에 `x as any` 처럼 타입 단언을 사용하는 방법이 그나마 낫다는 의견이다.

**객체**에서의 사용 시에는 객체 전체를 단언하는 것보다는, 최소한의 범위에만 any를 사용할 수 있도록 해야한다.

이처럼 최소한의 범위에서 any를 사용하는 것은 의도하지 않은 타입 안전성의 손실을 피하기 위해서이다. 또한 강제로 타입 오류를 제거하려면 any 대신 `@ts-ignore`을 사용하는 것이 좋으나, 이또한 근본적인 해결 방법이 아니므로 유의해야 한다.

## [아이템 39] any를 구체적으로 변형해서 사용하기

any는 어떤 타입이라도 받을 수 있기 때문에, 불가피하게 any를 사용하더라도 최대한 구체적인 형태로 사용하자.

```
1. any[]
2. {[key: string]: any}
3. () => any
```

하지만 이렇게 사용하기 이전에 정말로 any가 필요한 코드인지 확인한 후 쓰는게 좋을 것 같다.

## [아이템 40] 함수 안으로 타입 단언문 감추기

타입 단언문을 불가피하게 사용해야 하는 경우에는 함수 내부에 숨겨서 사용하자는 내용이다.
대신 함수 외부에 드러나는 타입 정의를 정확하게 명시하는 것이 좋다.

또한 객체가 같은지 체크하기 위해 객체 순회와 단언문이 코드에 직접 들어가는 것보다, 앞의 코드처럼 별도의 함수로 분리해 내는 것이 훨씬 좋은 설계라고 할 수 있다.

## [아이템 41] any의 진화를 이해하기

일반적인 타입들과는 달리, 암시적 any와 any[] 타입은 타입이 확장되며 진화할 수 있음을 이야기하고 있다.

any 타입의 진화는 암시적인 any인 변수에 다른 값을 할당할 때 발생한다.

변수를 선언할 때 초기화하지 않거나, 배열을 선언할 때 빈 배열을 선언하게 되는 경우에 각각 any, any[]로 암시적으로 추론된다.

<-> 변수 선언 시 any를 명시적으로 할당하는 경우에는 진화가 발생하지 않는다.

아래 예시들을을 통해 다시 보면,

any 타입인 배열 []은 `any[]` 로 선언이 되었지만 number 타입의 값을 넣는 순간부터 타입은 number로 진화(evolve)하게 된다. 즉, 이처럼 any 타입의 배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화하게 된다.

또한 조건문에서는 다음 코드와 같이 분기에 따라 타입이 변화할 수 있다.

```
let val;    // 타입이 any

if (Math.random() > 0.5) {
    val = /hello/;
    val     // 타입이 RegExp
} else {
    val = 12;
    val     // 타입이 number
}
val;        // 타입이 number | RegExp
```

위 코드에서 val이라는 변수에 명시적으로 any를 선언하면 타입이 any로 그대로 유지된다.

변수의 초기값이 null인 경우에도 any의 진화가 일어나게 되는데, 이 경우는 보통 try/catch 블록 내에서 변수를 할당하는 경우에 나타난다.

하지만 실수로 다른 타입 요소가 섞이면 잘못 진화할 수 있기 때문에, 타입을 안전하게 유지하기 위해서는 암시적 any를 진화시키는 것보다 명시적 타입 구문을 사용하는 것이 더 좋은 방법이다.

## [아이템 42] 모르는 타입의 값에는 any 대신 unknown을 사용하기

할당 가능성의 관점에서 unknown은

- 어떠한 타입이든 unknown 타입에 할당이 가능하다.
- unknown 타입은 어떠한 타입으로도 할당이 불가능하다.

이는 어떤 타입도 unknown에 넣을 수는 있지만, 어떤 타입으로토 사용할 수는 없다는 의미이다.

반연 any는,

- 어떠한 타입이든 any 타입에 할당이 가능하다.
- any 타입은 어떠한 타입으로도 할당이 가능하다.

즉, any는 어떤 타입도 받을 수 있고, 어떤 타입으로도 사용할 수 있다. 그렇기 때문에 사용하는 경우에 타입 체커의 검사를 받지 않으며 문제가 발생하게 된다.

unknown은 any 대신에 쓸 수 있는 타입 시스템에 부합하는 타입이다. 이때 unknown 상태로 사용하려 하면 오류가 밣생하기 때문에 적절한 타입으로 변환하도록 강제하여 사용할 수 있다.

### {} vs object vs unknown

unknown과 유사하나 조금 타른 타입으로는,

- {}: null과 undefined를 제외한 모든 값을 가질 수 있다.
- unknown: 모든 값을 가질 수 있다다
- object: 원시 타입을 제외한 모든 타입을 가질 수 있다.

**가질 수 있는 값의 범위: unknown > object > {}**

결론적으로는, unknown은 any 대신에 사용할 수 있는 안전한 타입으로, 어떠한 값이 있지만 그 타입을 알지 못하는 경우에 사용하도록 하자는 이야기이다.

또한 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제하려는 경우에 unknown을 사용하면 된다.

## [아이템 43] 몽키 패치보다는 안전한 타입을 사용하기

_+) 몽키패치는 원래 소스코드를 변경하지 않고 실행 시 코드 기본 동작을 추가, 변경 또는 억제하는 기술이다. 쉽게 말해 어떤 기능을 위해 이미 있던 코드에 삽입하는 것이다._

자바스크립트는 객체와 클래스에 임의의 속성을 추가할 수 있을 만큼 유연하다는 특징이 있다.

`window`나 `document`에 값을 할당해 전역 변수를 만드는 경우나, DOM 요소에 데이터를 추가하는 경우, 내장 기능의 프로토타입에 속성을 추가하는 경우가 있는데, 이처럼 객체에 임의의 속성을 추가하는 것은 일반적으로 좋은 설계라고 할 수 없다.

타입스크립트 관점에서 본다면 타입 체커는 내장 속성에 대해서는 알고 있지만, 임의로 추가한 속성에 대해서는 알지 못하기 때문이다. 물론 any 단언문을 통해 해결할 수는 있으나, 타입 안전성을 잃어버린다.

해결을 위해서는,

1. document 또는 DOM으로 부터 데이터를 분리
2. 1번이 불가능한 경우, 즉 객체와 데이터가 붙어 있어야만 하는 라이브러리를 사용하거나, 자바스크립트 애플리케이션을 마이그레이션하는 중이라면

- 2-1. 인터페이스 보강(augmentation) 기능 사용하기

```
interface Document {
  monkey: string;
}
document.monkey = "m"; // 정상 동작
(document as any).monky = "m"; // Error: 'monky' 속성이 'Document' 형식에 없습니다. 'monkey'을(를) 사용하시겠습니까?
```

- 2-2. 더 구체적인 타입 단언 사용하기

```
interface MonkeyDocument extends Document {
  monkey: string;
}
(document as MonkeyDocument).monkey = "m"; // 정상 동작
```
