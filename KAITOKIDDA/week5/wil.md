## item44 타입 커버리지를 추적하여 타입 안전성 유지하기

- item5 내용처럼 any 타입은 타입 안정성과 생선성에 부정적인 영향을 줄 수 있다.
- noImplicitAny를 설정하고 모든 암시적 any 대신 명시적 타입 구문을 추가해도 any 타입과 관련된 문제들로부터 안전하다고 할 수 없다.

- any 타입이 여전히 프로그램 내에 존재할 수 있는 경우

  - 명시적 any 타입

    - ex) any[], {[key : string] : any}

  - 서드파티 타입 선언

    - @types 선언 파일로부터 any 타입이 전파되기 떄문에 주의 요함
    - 선언된 타입과 실제 반환 타입이 맞지 않아서 any 단언문을 사용했으나 추후에 함수 선언문이 제대로 수정된 경우
    - 전체 모듈에 any 타입이 부여된 경우

      ```typescript
      declare module "my-module"; // my-module에서 어떤 것이든 오류 없이 import 가능
      // 타입 정보가 모두 제거되어 import한 모든 심벌은 any 타입

      import { someMethod, someSymbol } from "my module";

      const pt1 = {
        x: 1,
        y: 2,
      }; // 타입이 {x: number, y: number}
      const pt2 = someMethod(pt1, someSymbol); // 정상, pt2의 타입이 any
      ```

### 프로젝트에서 any의 개수를 추적하는 방법

```
$ npx type-coverage
```

결과는 {any가 아니거나 any의 별칭이 아닌 타입을 가진 심벌 수} / {전체 심벌 수} {백분율}

```
$ npx type-coverage --detail
```

**--detail 플래그**를 붙이면 any 타입이 있는 곳을 모두 출력해 준다.

# 8장 타입스크립트로 마이그레이션하기

- 낡은 자바스크립트 프로젝트를 꾸준하게 타입스크립트로 마이그레이션하는 방법

## item58 모던 자바스크립트로 작성하기

- 타입 스크립트는 타입 체크 기능 외에도 타입스크립트 코드를 특정 버전의 자바 스크립트로 컴파일(트랜스파일)하는 기능도 가지고 있음

- 타입스크립트는 자바스크립트의 상위집합이기 때문에, 최신 버전의 자바스크립트 코드를 옛날 버전의 자바스크립트 코드로 변환할 수 있음. 옛날 버전의 자바스크립트 코드를 타입스크립트 컴파일러에서 동작하게 하면 이후에는 최신 버전의 자바스크립트 기능을 코드에 추가해도 문제가 없음

- 마이그레이션 시 옛날 버전의 자바스크립트를 최신 버전의 자바스크립트로 바꾸는 작업부터 시작할 것

- 다음은 모던자바스크립트(ES6) 부터의 주요 기능에 대한 설명이다. 아래의 기능을 사용하도록 기존 자바스크립트 코드를 수정해주자.

## 모던 자바스크립트 주요 기능

- ECMAScript 모듈

  - import와 export를 사용하는 표준 모듈

- 프로토타입 대신 클래스 사용하기

- var 대신 let/const 사용하기

  - JS var 키워드의 scope 규칙에는 문제가 있음
  - 중첩된 함수 구문에도 비슷한 스코프 문제가 존재. 함수 표현식을 사용하여 호이스팅 문제를 피해야 함

- for(;;) 대신 for-of 또는 배열 메서드 사용하기

  - 코드가 짧고 인덱스 변수를 사용하지 않기 때문에 실수를 줄일 수 있음
  - 인덱스 변수 필요 시 forEach 메서드 사용

- 함수 표현식보다 화살표 함수 사용하기

  - this 키워드의 경우 다른 스코프 규칙을 가지므로 예상치 못한 결과가 나오기도 하므로 화살표 함수를 사용하자.
  - 인라인 또는 콜백 함수에는 일반함수보다 화살표 함수가 더 직관적이므로 가급적 화살표 함수를 사용하자.

- 단축 객체 표현과 구조 분해 할당 사용하기

  - 단축 객체 표현

  ```javascript
  const { props } = obj;
  const { a, b } = props;
  ```

  - 객체 구조 분해

  ```javascript
  const props = obj.props;
  const a = props.a;
  const b = props.b;
  ```

  ```javascript
  const { props } = obj;
  const { a, b } = props;
  ```

  ```javascript
  const {
    props: { a, b },
  } = obj;
  ```

- 함수 매개변수 기본값 사용하기

  - 기본값 기반으로 타입 추론이 가능해 마이그레이션 시 매개변수에 타입 구문을 쓰지 않아도 됨

- 저수준 프로미스나 콜백 대신 async/await 사용하기

  - 코드가 간결해져 버그, 실수 방지 및 비동기 코드에 타입 정보가 전달되어 타입 추론이 가능해짐

- 연관 배열에 객체 대신 Map과 Set 사용하기

- 타입스크립트에 use strict 넣지 않기

  - 타입스크립트에서 수행되는 안전성 검사가 훨씬 더 엄격한 체크를 함
  - 타입스크립트 컴파일러가 생성하는 자바스크립트 코드에서 'use strict'가 추가 되므로 대신 **alwaysStrict** 설정을 사용해야 함

- 타입스크립트 개발팀은 자바스크립트 표준화 4단계 중 3단계 이상의 기능들을 타입스크립트 내에 구현하고 있음. 자바스크립트 표준단체 TC39에서 깃허브 저장소와 타입스크립트의 릴리스 노트를 통해 최신 기능 확인 가능.

## item59 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기

- 본격적으로 타입스크립트로 전환하기 전에, **@ts-check** 지시자를 사용하면 타입스크립트 전환 시 발생가능한 오류가 뭐가 있을지 미리 테스트해볼 수 있음

- noImplcitAny 설정을 해제한 것보다 헐거운 수준의 체크를 수행함

- @ts-check 지시자 사용법

```javascript
// @ts-check
const person = { first: "Grace", last: "Hopper" };
2 * person.first;
// 산술 연산 오른쪽은 'any', 'number', 'bright' 또는 열거형 형식이어야 합니다.
```

- 타입 불일치, 함수 매기변수 개수 불일치 같은 오류를 찾아낼 수 있다
- 선언되지 않은 전역 변수 오류를 찾아낼 수 있다.
- 서드파티 라이브러리들의 타입 선언을 활용하여 타입체크를 시험해 볼 수 있다.

- 자바스크립트 파일에 타입스크립트 단언문을 사용해야 할 때 JSDoc를 사용해 대체함. 이 경우 @type 구문을 사용 시 타입을 감싸는 중괄호 필요

- 프로젝트에 이미 JSDoc 스타일의 주석 사용했을 때 @ts-check 지시자 설정 시 기존 주석에 타입체크가 동작해 수많은 오류가 발생. (ex) DOM 타입 불일치, 명시된 타입과 실제 반환 타입 불일치 등. 당황하지 말고 타입 정보를 차근차근 추가할 것

- JSDoc 주석을 통해 자바스크립트 상태에서 타입 단언, 타입 추론을 할 수 있지만 과도하게 사용하면 코드가 길어져 가독성을 해칠 수 있음. 우리의 목표는 타입스크립트 코드로 마이그레이션하는 것이므로 너무 공들이지는 말 것.

## item60 allowJs로 타입스크립트와 자바스크립트 같이 사용하기

- 대규모 프로젝트는 한꺼번에 타입스크립트로 전환하는 작업이 불가능하므로 마이그레이션 기간 중 JS와 TS가 동시에 동작할 수 있게 하기 위해 **allowJs 컴파일러 옵션**을 사용해야함

- 대규모 마이그레이션 작업 시작 전, 테스트와 빌드 체인에 타입스크립트를 적용해야 함

## item61 의존성 관계에 따라 모듈 단위로 전환하기

- 다른 모듈에 의존하지 않는 최하단 모듈부터 작업을 시작해 의존성의 최상단에 있는 모듈을 마지막으로 완성해야함

- 첫째로 서드파티 모듈과 외부 API 호출에 대한 @types를 추가해야 함. 프로젝트 내 모듈들은 얘네들에 의존하지만 얘네들은 그렇지 않기 때문에 먼저 해결함.

- 의존성 관계도의 아래에서부터 위로 올라가며 마이그레이션을 진행. 첫 번째 모듈은 보통 유틸리티 모듈임. 의존성 관계도를 시각화하여 진행과정을 추적할 것

- 마이그레이션 시 코드 리팩토링은 진행해서는 안되며, 따로 목록을 만들어 기록해둘 것

- 타입스크립트로 전환하며 발견되는 일반적인 오류들

  - 선언되지 않은 클래스 멤버

    - 자바스크립트는 클래스 멤버 변수를 선언할 필요가 없지만, 타입스크립트에서느 명시적으로 선언해야함.
    - quick fix 누락된 모든 멤버 추가 기능을 적용 후 속성을 훑어보고 any로 추론된 부분은 직접 수정

  - 타입이 바뀌는 값

    - 객체를 한꺼번에 생성하거나 임시 방편으로 타입 단언문 사용 후 마이그레이션 완료 후 수정

  - 타입 스크립트 전환 시 @ts-check와 JSDoc는 작동하지 않음
    - JSDoc 타입 정보를 타입 스크립트 타입으로 전환해 주는 quick fix 기능 사용. 이후 불필요해진 JSDoc 제거

- 마지막 단계로, 테스트 코드를 타입스크립트로 전환. 로직 코드가 테스트 코드에 의존하지 않기 때문에, 마이그레이션 동안 테스트를 수행할 수 있는 것이고, 테스트 코드는 항상 의존성 관계도의 최상단에 위치하므로 마이그레이션의 마지막 단계인 것.

## item62 마이그레이션의 완성을 위해 noImplicitAny 설정하기

- 프로젝트 전체를 .ts로 전환했다고 해도 마이그레이션이 완성된 것은 아님. 타입 선언에서 비롯되는 실제 오류가 숨어있기 때문에 **noImplicitAny**를 설정해야함

- noImpliciAny를 로컬에만 설정해 점진적으로 수정하여 마이그레이션해야 함

- noImplicitAny는 상당히 엄격한 설정이며 최종적으로 가장 강력한 설정은 ''strict": true임. 타입체크의 강도는 팀원들이 타입스크립트에 익숙해진 후 점진적으로 올려야 함
